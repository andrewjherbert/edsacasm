; EDSAC STORE TEST - ANDREW HERBERT - 22/12/2021;; Operates in 7 phases:; Phase 0: all zeros; Phase 1: all 1s; Phase 2: addresses; Phase 3: inverted addresses; Phase 4: checkerboard; Phase 5: inverted checkerboard; Phase 6: checkered addresses; Phase 7: inverted checkered addresses;*19;((EXTENDED STORE TEST WITH OCTAL OUTPUT, 25/5/15);[];<;XSTORE   4     +141;         15    6148;         4     +10;         15    6148;         15    2052;         6     +127      (Ignore Parity);         1     -48;         9     ;-3       (Ignore Controls & Blanks but not Erases);         14    13;         6     =7 0;         5     MODULE;         7     ;+4;         5     AFIRST          T .SPARE. D		; Calculate first free address	  A .FIRST. F	  RD	  T .AFIRST. F;         1     =1 0;         8     ;+4;         4     =0 183    (From FIRST NEXT message);         5     AFIRST;         4     =0 8180;         5     ANEXT;         4     +0;         5     PHASE          T .SPARE. F	  T .PHASE. F;PLOOP    4     +0;         5     ERRORS;         4     AFIRST;         5     POINTR.PLOOP.   T .ERRORS. F		; assumes Acc = 0	  A .AFIRST. F	  U .POINTR. F;ALOOP    2     ANEXT;         7     AEXIT.ALOOP.   S .ANEXT. F		; Test if POINTR = ANEXT          G ;+2 F		; POINTR < ANEXT	  E .AEXIT. F		; POINTR >= ANEXT ;        4     PHASE ;        6     +4 ;        7     ;+2       (Jump iff not ASCENDING) ;        4     POINTR ;        5     PATERN (+2)     T .SPARE. F	  H .PHASE. F	  C .FOUR. F	  S .ONE. F	  G .NOTASC. F			  E .ASCEND. F.NOTASC.  T .SPARE. F		; not ASCENDING, PATERN := 0	  E ;+3 F	   .ASCEND.  T .SPARE. F		; ASCENDING, PATERN := POINTER	  A .POINTR. F(+3)	  T .PATERN. F	  ;         4     PHASE;         6     +2;         7     ;+4       (Jump iff not INVERTED);         4     PATERN;         2     -1;         5     PATERN	  T .SPARE. F	  C .TWO. F	  S .ONE. F	  G .NOTINV. F		; not INVERTED	  T .ZERO. F		; INVERTED, PATERN := ! PATERN 	  S .PATERN F	  S .ONE. F	  T .PATERN F;         4     PHASE;         6     +8;         7     NOTCHQ    (Jump iff not CHEQUERED);         4     POINTR;         6     &003;         7     ;+6;         2     &003;         7     ;+4;         4     PATERN;         2     -1;         5     PATERN;         4     POINTR;         6     &300;         7     ;+6;         2     &300;         7     ;+4;         4     PATERN;         2     -1;         5     PATERN.NOTINV.  T .SPARE. F          H .PHASE. F          C .EIGHT. F	  S .ONE. F	  G .NOTCHQ. F		; not CHEQUERED	  T .SPARE. F           ; CHECKERED, chequer the pattern	  H .POINTER. F	  C .O003. F	  S .ONE. F	  G .NI1. F	  A .ONE. F	  T .SPARE. F	  A .O003. F	  S .SPARE. F	  S .ONE. F	  G .NI1.	  T .SPARE. F	  S .ONE. F	  S .PATERN. F	  T .PATERN. F.NI1.     T .SPARE. F	  H .POINTR. F	  C .O300. F          S .ONE. F	  G .NOTCHQ. F	  A .ONE. F	  T .SPARE. F	  A .O300. F	  S .SPARE. F	  S .ONE. F	  G .NOTCHQ. F	  T .SPARE. F	  S .ONE. F	  S .PATERN. F	  T .PATERN. F	  ;NOTCHQ   4     PHASE;         6     +1;         7     CONTIN    (Jump iff not READBACK);;         0     POINTR;         4     PATERN;         5     EXPECT;         /2    0;         7     ;+2;         8     FAILED;         4     PATERN;         2     -1;         5     EXPECT;         /5    0;         /2    0;         7     ;+2;         8     FAILED;         4     PATERN;         5     EXPECT;         /5    0;         /2    0;         7     CONTIN.NOTCHQ.  H .PHASE. F	  C .ONE. F	  S .ONE. F	  G .CONTIN. F          T .SPARE. F	  A .PATCH1. F	  A .POINTR. F	  T .PAT1. F	  A .PATERN F.PAT1.    Z0F			; becomes S .POINTR. F          G .FAILED1. F	  A .ONE. F	  E .FAILED2. F	  T .SPARE. F	  A .PATCH2. F	  A .POINTR. F	  T .PAT2. F	  A .PATCH3. F	  A .POINTR. F	  T .PAT3. F	  S .ONE. F	  S .PATERN. F	  T .EXPECT. F.PAT2.    Z0F			; becomes U .POINTR. F.PAT3.    Z0F			; becomes S .POINTR. F	  G .FAILED3. F	  S .ONE. F	  G .FAILED4. F.FAILED1. Z1F.FAILED2. Z2F.FAILED3. Z3F.FAILED4. Z3F;FAILED   5     ERROR;         10    ERRORS;         4     ERRORS;         2     +20;         9     CONTIN    (Jump iff 20 < ERRORS);         4     +135;         15    6148;         4     +141;         15    6148;         4     +10;         15    6148;         4     POINTR;         11    SLOPL;         8     SLOPO;         15    6148;         4     EXPECT;         11    SLOPL;         8     SLOPO;         15    6148;         4     ERROR;         11    SLOPL;         8     SLOPO;CONTIN   0     POINTR;         4     PATERN;         /5    0;         10    POINTR;         4     POINTR;         8     ALOOP.CONTIN.  T .SPARE. F          A .POINTR. F	  A .PATCH4. F	  T .PAT4. F	  S .PATCH4. F.PAT4.	  Z0F			; becomes T .POINTR. F          A .POINTR. F	  A .ONE. F	  U .POINTR. F	  E .ALOOP. F;AEXIT    4     PHASE;         6     +1;         7     NEXTP     (Jump iff not READBACK);;         4     +141;         15    6148;         4     +10;         15    6148;         4     PHASE;         14    8191;         6     +7;         1     MODULE;         11    SLOPL;         8     SLOPO;         15    6148;         4     ERRORS;         11    SLOPL;         8     SLOPO.AEXIT.   T .SPARE. F	  H .PHASE. F	  C .ONE. F	  G .NEXTP. F	  S .ONE. F	  E .NEXTP. F	  ; monitoring here	  ;NEXTP    10    PHASE;         8     PLOOP.NEXTP.   T .SPARE. F	  A .PHASE. F	  A .ONE. F	  T .PHASE. F	  E .PLOOP. F.ANEXT.	  +0.POINTR.  +0.PHASE.	  +0.PATERN.  +0.EXPECT   +0.ERROR.   +0.ERRORS.  +0.ONE.     +1.AFIRST. P ;+1 F