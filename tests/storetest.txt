; EDSAC STORE TEST - ANDREW HERBERT - 02/01/2022; Based on Elliott 900 XSTORE by Terry Froggatt.; The program runs eight "write" phases, in which; the whole store is first set to a known pattern.; Each is followed by a "read" phase which, for each word,; checks that that word is right, then inverts it and checks; that that is right, then sets it back and checks that's OK.; The first 2 phases set all zeros, and then all ones,; so give a straighforward go/nogo test of the data bits.; The next 2 phases write the address to the location,; ("ascending"), then the inverse of the address,; so a different value is written to every word,; which should flush out any addressing failures.; The next 2 phases use a chequerboard all zeros/all ones; pattern. The final 2 phases use chequered addresses.; (These tests are more relevant to a core store, but may; stress the EDSAC store by replacing 1s with 0s in blocks.; A three-word output indicates an error, giving the address,; the expected data, and the error (actual-expected).; Only the first 20 errors of each phase are printed.; A two-word output is given at the end of each phase,; test number (0 to 7), then the number of errors from that; test. ;;Summary; Phase 0: all zeros; Phase 1: all 1s; Phase 2: addresses; Phase 3: inverted addresses; Phase 4: checkerboard; Phase 5: inverted checkerboard; Phase 6: checkered addresses; Phase 7: inverted checkered addresses; Flags; PHASE & 1 = 1 -- READBACK; PHASE & 2 = 2 -- INVERTED; PHASE & 4 = 4 -- ASCENDING; PHASE & 8 = 8 -- CHEQUERED.XSTORE.  O .FS. F		; Set figure shift	  T .WORK. F		; Clear Acc          T .PHASE. F		; Set PHASE = 0	  A .AFIRST. F		; Calculate first free address	  RD	     		; Shift down address field	  T .AFIRST. F		; Save; Start next phase.PLOOP.   T .ERRORS. F		; Assumes Acc = 0 - reset ERRORS	  A .AFIRST. F	  U .POINTR. F		; Set POINTR = AFIRST; Process next address.ALOOP.   S .ANEXT. F		; Assumes Acc = POINTR; Test if POINTR = ANEXT          G .AL1. F		; POINTR < ANEXT	  E .AEXIT. F		; POINTR >= ANEXT .AL1.    T .WORK. F	  H .PHASE. F	  C .+4. F	  S .+1. F	  G .NOTASC. F			  E .ASCEND. F	  .NOTASC.  T .WORK. F		; not ASCENDING, set PATERN = 0	  E .AL2. F	   .ASCEND.  T .WORK. F		; ASCENDING, set PATERN := POINTER	  A .POINTR. F.AL2.	  T .PATERN. F	  T .WORK. F	  C .+2. F	  S .+1. F	  G .NOTINV. F		; not INVERTED.INVERT.  T .WORK. F		; INVERTED, set PATERN = ! PATERN 	  S .PATERN. F	  S .+1. F	  T .PATERN. F.NOTINV.  T .WORK. F          C .+8. F	  S .+1. F.CHQ.	  G .NOTCHQ. F		; not CHEQUERED	  T .WORK. F           ; CHECKERED, chequer the pattern	  H .POINTR. F	  C .O003. F	  S .+1. F	  G .NI1. F	  A .+1. F	  T .WORK. F	  A .O003. F	  S .WORK. F	  S .+1. F	  G .NI1. F	  T .WORK. F	  S .+1. F	  S .PATERN. F	  T .PATERN. F.NI1.     T .WORK. F	  H .POINTR. F	  C .O300. F          S .+1. F	  G .NOTCHQ. F	  A .+1. F	  T .WORK. F	  A .O300. F	  S .WORK. F	  S .+1. F	  G .NOTCHQ. F	  T .WORK. F	  S .+1. F	  S .PATERN. F	  T .PATERN. F.NOTCHQ.  H .PHASE. F	  C .+1. F	  S .+1. F	  G .CONTIN. F		; Jump iff not READBACK          T .WORK. F	  A .S0F. F	  A .POINTR. F		; Calculate address field = POINTR*2	  A .POINTR. F	  T .PAT1. F	  A .PATERN. F		; Expect PATERN	  U .EXPECT. F.PAT1.    Z0F			; Becomes S .POINTR. F -- should compute 0          G .FAILED. F		; < 0 : Fail	  S .+1. F	  E .FAILED1. F		; = 0 : Pass	  T .WORK. F	  A .U0F. F	  A .POINTR. F		; Calculate address field = POINTR*2	  A .POINTR. F	  T .PAT2. F	  A .S0F. F	  A .POINTR. F		; Calculate address field = POINTR*2	  A .POINTR. F	  T .PAT3. F	  S .+1. F	  S .PATERN. F	  U .EXPECT. F.PAT2.    Z0F			; Becomes U .POINTR. F.PAT3.    Z0F			; Becomes S .POINTR. F	  G .FAILED. F	  S .+1. F	  E .FAILED1. F	  G .CONTIN. F.FAILED1. A .+1. F              ; Reset ERROR.FAILED.  T .ERROR. F	  A .ERRORS. F	  A .+1.F	  U .ERRORS. F	  S .+21. F	  G .CONTIN. F	  O .CR. F		; Output error report	  O .LF. F	  T .WORK. F	  A .POINTR. F		; Faulty address	  T .WORK. F	  A ;+0 F	  G .PRTOCT. F	  O .SP. F	  T .WORK. F	  A .EXPECT. F		; Expected result	  T .WORK. F	  A ;+0 F	  G .PRTOCT. F	  T .WORK. F	  A .ERROR. F		; Error patterns	  T .WORK. F	  A ;+0 F	  G .PRTOCT. F.CONTIN.  T .WORK. F          A .POINTR. F	  A .POINTR. F	  A .T0F. F	  T .PAT4. F	  A .PATERN. F.PAT4.	  Z0F			; Becomes T .POINTR. F          A .POINTR. F		; Increment address pointer	  A .+1. F	  U .POINTR. F	  E .ALOOP. F.AEXIT.   T .WORK. F		; End of address 	  H .PHASE. F	  C .+1. F	  S .+1. F	  G .NEXTP. F		; Jump iff not READBACK	  C .+14. F		; Mask out phase	  L 16 F		; Shift 11 places left	  L 8 F	  T .WORK. F	  O .WORK. F		; Type phase	  	  O .SP. F		; Type space	  	  A .ERRORS. F          ; Output error count	  T .WORK. F	  A ;+0 F    		; Call .PRTOCT.	  G .PRTOCT. F	  O .CR. F  		; Type CRLF	  O .LF. F	  O .FS. F	  	  .NEXTP.   T .WORK. F	  A .PHASE. F	  A .+1. F	  T .PHASE. F	  E .PLOOP. F	  G .PLOOP. F; Subroutine to output number in .WORK. in octal form.PRTOCT.  A .U2F. F		; Standard subroutine entry	  T .PRRET. F	  S .+6. F	  T .POCNT. F	  A .WORK. F	  R2F.POLOOP.  T .WORK. D	  H .MASK. D	  C .WORK. D	  T .WORK. D	  O .WORK. D	  A .POCNT. F	  A .+1. F	  E .PRRET. F	  T .POCNT. F	  A .WORK. D	  L2F	  E .POLOOP. F	  G .POLOOP. F	  .PRRET.   +0			; Patched with return; Variables.ANEXT.	  +1024			; size of store.ERROR.   +0.ERRORS.  +0.EXPECT.  +0.PATERN.  +0.PHASE.	  +0.POINTR.  +0.POCNT.   +0; Constants.S0F.     S0F.T0F.     T0F.U0F.     U0F.U2F.     U2F.+1.      +1.+2.      +2.+4.      +4.+6.	  +6.+8.      +8.+14.     +14.+21.     +21.O003.    &003.O300.    &300.CR.	  B10010000000000000	; Carriage return.LF.	  B11000000000000000	; Line feed.FS.	  B01011000000000000	; Figure shift.SP.      B10100000000000000	; Space@.MASK.    B00111111111111111111111111111111111L.WORK.    +0L			; Workspace.AFIRST. P ;+1 F                ; First free address