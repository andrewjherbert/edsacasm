EDSAC TEST PROGRAM ASSEMBLER============================Andrew Herbert - 17/12/2023The EDSAC TEST PROGRAM ASSEMBLER (edsacasm) is a simple assembler for writing short testprograms to be loaded into EDSAC store tank 0 using the Signal Sequence Injector (SSI).It is an interim facility until such time as test programs can be loaded using EDSACinitial orders.esacasm is written in Python3 so that it can be readily run on any MacOS, MicrosoftWindows or Linux computer with a Python3 system installed.COMMAND LINE------------python3 edsacasm.py [-h] [-list] input-file [-o|out-file]-h             prints help on edsacasm command-list          produce a listing as outputinput_file     path to source program to assemble-o=outfile     path to destination file for outputif no output-file is specified, the output is sent to stdout.if -list is absent the output is a series of binary numbers, one per line for each ofthe 64 words of tank 0, suitable for loading via the SSI, for example: 001010000001011010 111000000001000010 110110000000011000 111000000001010010 000110000000011000 110110000000011100 011010000000000100 001010000001011010 ... 000000000000000000 000000000000000000 000000000000000000 000000000000000000if -list is present the output is annotated with word number in decimal and a decode ofthe content of that location as an EDSAC order, for example: 0 001010000001011010    T22D 1 111000000001000010    A16D 2 110110000000011000    G6F 3 111000000001010010    A20D 4 000110000000011000    E6F 5 110110000000011100    G7F 6 011010000000000100    Z1F 7 001010000001011010    T22D 8 111000000001010010    A20D 9 111000000001001010    A18D10 110110000000111000    G14F...This output format is intended to be useful for debugging and monitoring the execution ofthe program during testing.ASSEMBLY CODE-------------The assembler is rudimentary.  It allows the input of EDSAC orders and short numbers in aform similar to that expected by the initial orders.  It also permits use of labels inaddition  to absolute addresses and the addition of comments.  It does not provide any ofthe EDSAC initial orders facilities to support the use of library subroutines, floatingcode etc.The assembler is free format.  It reads a sequence of items where an item can be:1) a comment consisting of a semicolon (;) followed by arbitrary text terminate by anewline.2) a decimal number consisting of a + or - sign followed by a sequence of decimaldigits.3) a octal number consisting of an & symbol followed by a sequence of octal digits(0-7). In addition the digit '8' can be used to insert a single 0 bit in the number andthe digit '9' can be used to insert a single 1.  This is a useful facility forconstructing words containing sub-fields.  For example, &7890 represents the binary number11101000.4) an order consisting of a single function letter (e.g., A, S, H, etc), and address and asingle length designator letter - F for short number operations, D for long numberoperations.7) the symbol '@' to caused the next item to be asse,bled into am even numbered storelocation - generally used with double constants.The assembler recognises all the hardware defined operations plus P as a pseudo functionwith code 0.  The  P code provides another way to enter numbers as is done in programsintended to be loaded by initial orders.If a number is followed by the letter L it is stored as a long number (i.e., 35 bits),otherwise it is stored as a short number (i.e., 17 bits).An address can be an absolute address expressed as a decimal integer in the range0-63, a reference to a label or a relative address.  If the address field is omitted froman order, 0 is assumed.  A relative address takes the form #+nn or #-nn where nn is adecimal integer.  The formed address is the address of the current instruction plus orminus the integer as appropriate.  Thus ;-1 represents the previous location to thecurrent instruction and ;+1 the next instruction.Labels consist of arbitrary text bracketed by full stops (.), as in .label. .1234. etc.Any number of labels may be written before a comment, a number or an order.  The labelbe assigned the address into which that number or order will be assembled.When a label appears as an address in an order the address associated with the labelwill be written to the order's address field.Newline, space and tab characters can be used between items to improve layout.  Thus theassembler allows multiple orders and numbers to written on a single line if desired.The output shown earlier was produced by assembling the following input code:; FUNCTION TEST -  Addition part 1.START.; add 0 + 0			T .SPARE. D			A .ZERO. D		; 0 + 0			G ;+4 F			; 0 + 0 < 0 -- wrong			A .MINUS1. D		; 0 + 0 - 1			E ;+2 F			; 0 + 0 - 1 >= 0 -- wrong			G ;+2 F			; Pass			Z1F			    ; Fail; add -1 + 1 = 0			T .SPARE. D			A .MINUS1. D			A .ONE. D            G ;+4 F         ; -1+1 < 0			A .MINUS1. D			E ;+2 F			; -1+1-1 >= 0 -- wrong			G .START. F		; Pass			Z2F			    ; Fail; data - align on even address@.ZERO.      	      +0L.ONE.       	      +1L.MINUS1.    	      -1L.SPARE.               B0LLOADING OUTPUT VIA SSI----------------------Instructions for loading code into the SSI are given in HN95 Signal Sequence Injector. Thebasic mechanism is to connect a computer, e.g., a laptop to a USB port on the SSI unit,connect to the SSI using minicom and then upload a file of binary numbers produce by theassembler running with out the -list option.The ssiupload.py program included in this repo automates this process and guides theoperator through the required steps on the SSI.